# -*- coding: utf-8 -*-
"""noise_03.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Rpa6pKT_qItettQlxQuQ8vQ5nNcdzFv0
"""

import numpy as np
import matplotlib.pyplot as plt

# Generate synthetic data with spikes
def generate_data(n_samples, spike_freq, spike_magnitude):
    x = np.linspace(0, 10, n_samples)
    y_true = x**2

    # Generate spikes
    spikes = np.zeros(n_samples)
    n_spikes = int(spike_freq * n_samples)
    spike_indices = np.random.choice(n_samples, n_spikes, replace=False)
    spikes[spike_indices] = spike_magnitude * (2 * np.random.rand(n_spikes) - 1)

    y_noisy = y_true + spikes

    return x, y_true, y_noisy

# Define different types of noise
def add_gaussian_noise(y, std_dev):
    return y + np.random.normal(0, std_dev, y.shape)

def add_uniform_noise(y, low, high):
    return y + np.random.uniform(low, high, y.shape)

def add_salt_and_pepper_noise(y, amount, salt_vs_pepper=0.5):
    noisy_y = y.copy()
    n_salt = int(np.ceil(amount * y.size * salt_vs_pepper))
    n_pepper = int(np.ceil(amount * y.size * (1.0 - salt_vs_pepper)))

    # Salt noise (max value)
    salt_indices = np.random.choice(np.arange(y.size), n_salt, replace=False)
    noisy_y.flat[salt_indices] = noisy_y.max()

    # Pepper noise (min value)
    pepper_indices = np.random.choice(np.arange(y.size), n_pepper, replace=False)
    noisy_y.flat[pepper_indices] = noisy_y.min()

    return noisy_y

def add_poisson_noise(y):
    y_shifted = y - y.min()  # Shift data to be non-negative
    noisy_y = np.random.poisson(y_shifted)
    return noisy_y + y.min()  # Shift back to original range

def add_speckle_noise(y, std_dev):
    return y + y * np.random.normal(0, std_dev, y.shape)

# Simple polynomial regression model
class LinearRegression:
    def __init__(self, degree=2):
        self.degree = degree
        self.weights = None

    def fit(self, X, y):
        X_aug = np.column_stack([X**i for i in range(1, self.degree + 1)])
        self.weights = np.linalg.pinv(X_aug).dot(y)

    def predict(self, X):
        X_aug = np.column_stack([X**i for i in range(1, self.degree + 1)])
        return X_aug.dot(self.weights)

# Evaluation metrics
def evaluate_model(y_true, y_pred):
    mse = np.mean((y_true - y_pred)**2)
    r2 = 1 - np.sum((y_true - y_pred)**2) / np.sum((y_true - np.mean(y_true))**2)
    return mse, r2

# Spike frequencies to test
spike_frequencies = np.linspace(0, 0.5, 20)

# Define combined noise functions
def combine_noises(y, noise_funcs):
    noisy_y = y.copy()
    for noise_func in noise_funcs:
        noisy_y = noise_func(noisy_y)
    return noisy_y

# Define noise combinations (2, 3, 4, and 5 noises)
noise_combinations = {
    'Gaussian + Uniform': lambda y: combine_noises(y, [
        lambda y: add_gaussian_noise(y, std_dev=5),
        lambda y: add_uniform_noise(y, low=-5, high=5)
    ]),
    'Gaussian + Salt-and-Pepper + Poisson': lambda y: combine_noises(y, [
        lambda y: add_gaussian_noise(y, std_dev=5),
        lambda y: add_salt_and_pepper_noise(y, amount=0.05),
        add_poisson_noise
    ]),
    'Gaussian + Uniform + Poisson + Speckle': lambda y: combine_noises(y, [
        lambda y: add_gaussian_noise(y, std_dev=5),
        lambda y: add_uniform_noise(y, low=-5, high=5),
        add_poisson_noise,
        lambda y: add_speckle_noise(y, std_dev=0.5)
    ]),
    'All Noises': lambda y: combine_noises(y, [
        lambda y: add_gaussian_noise(y, std_dev=5),
        lambda y: add_uniform_noise(y, low=-5, high=5),
        lambda y: add_salt_and_pepper_noise(y, amount=0.05),
        add_poisson_noise,
        lambda y: add_speckle_noise(y, std_dev=0.5)
    ])
}

# Without Data Augmentation
mse_without_aug = []
r2_without_aug = []

for freq in spike_frequencies:
    x, y_true, y_noisy = generate_data(1000, freq, 5)

    model = LinearRegression(degree=2)
    X = np.column_stack([x**i for i in range(1, 3)])  # Polynomial features
    model.fit(X, y_noisy)
    y_pred = model.predict(X)

    mse, r2 = evaluate_model(y_true, y_pred)
    mse_without_aug.append(mse)
    r2_without_aug.append(r2)

# With Data Augmentation for combined noises
mse_with_comb_aug = {name: [] for name in noise_combinations.keys()}
r2_with_comb_aug = {name: [] for name in noise_combinations.keys()}

for noise_name, noise_func in noise_combinations.items():
    for freq in spike_frequencies:
        x, y_true, y_noisy = generate_data(1000, freq, 5)
        y_noisy_augmented = noise_func(y_noisy)  # Apply the noise combination

        model = LinearRegression(degree=2)
        X = np.column_stack([x**i for i in range(1, 3)])  # Polynomial features
        model.fit(X, y_noisy_augmented)
        y_pred = model.predict(X)

        mse, r2 = evaluate_model(y_true, y_pred)
        mse_with_comb_aug[noise_name].append(mse)
        r2_with_comb_aug[noise_name].append(r2)

# Plotting the results
plt.figure(figsize=(12, 10))

# MSE Plot
plt.subplot(2, 1, 1)
plt.plot(spike_frequencies, mse_without_aug, 'b-', label='Without Data Augmentation')
for noise_name, mse_values in mse_with_comb_aug.items():
    plt.plot(spike_frequencies, mse_values, '--', label=f'With {noise_name}')
plt.title('MSE vs Spike Frequency with Extended Noise Combinations')
plt.xlabel('Spike Frequency')
plt.ylabel('MSE')
plt.legend()

# R² Plot
plt.subplot(2, 1, 2)
plt.plot(spike_frequencies, r2_without_aug, 'b-', label='Without Data Augmentation')
for noise_name, r2_values in r2_with_comb_aug.items():
    plt.plot(spike_frequencies, r2_values, '--', label=f'With {noise_name}')
plt.title('R² vs Spike Frequency with Extended Noise Combinations')
plt.xlabel('Spike Frequency')
plt.ylabel('R²')
plt.legend()

plt.tight_layout()
plt.show()

