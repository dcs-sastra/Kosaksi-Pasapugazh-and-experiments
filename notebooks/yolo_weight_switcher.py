# -*- coding: utf-8 -*-
"""custom_yolo1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/custom-yolo1-e8e20fb6-0e0f-4770-b517-61584eb3ebe9.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20241217/auto/storage/goog4_request%26X-Goog-Date%3D20241217T103918Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D724b2de791b78491567799a27dfdfe979e0a0dea86db5e2a1b4b62659ed4e89e3a90dce23e9f84cf185a03bf83311819bb0891ffa4b185d4d9c0f208c777462bf2cf5e455b3e0a19d79b8d8f5ccaddc0f3ac7bbccbcca11ab2baee81e9be03d1b1c310b0be5bb740c706f487a69860446a393411d97597f7d0457c02ceac798227244f60054f2db8b79d6cb7301e821242ddd4a978b169327bea123977ac103fb15125076ed21e8fc0606143a151e92a34811e8bbc8f0e875102749ea089c7fd2d8ac4b77691e7ce11eb67c39dc30e2644bc2c0d023652569dc39bece7bff4541cf4dd3d8b25615686e3493d620caf1c55ef75e47970af1718baea3bb0b2c795

# Setting up
"""

!pip install ultralytics torch torchvision
!pip install opencv-python

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

import torch
from ultralytics import YOLO
import cv2
import random
import os

"""# Training custom weights
- train the model for custom data.yaml
"""

# Path to the custom YAML file
DATA_YAML_PATH = "/kaggle/input/police-uniform/Police uniform detection.v1i.yolov11/data.yaml"  # Update this to the correct path

# Path to a pre-trained YOLOv8 model weights or "yolov8n.pt", "yolov8s.pt", etc.
MODEL_WEIGHTS = "yolo11m.pt"  # Start with a smaller model for experimentation

# Directory to save trained model weights
SAVE_DIR = "/kaggle/working/runs/trained_weights"

# Training parameters
TRAINING_PARAMS = {
    "data": DATA_YAML_PATH,
    "epochs": 50,          # Number of training epochs
    "imgsz": 640,          # Image size for training
    "batch": 16,           # Batch size
    "device": "0",        # GPU ID ("0" for the first GPU; "cpu" to use CPU)
    "name": "custom_yolo", # Run name for easier identification
    "cache": True,         # Cache dataset for faster training
    "save_dir": SAVE_DIR   # Directory to save training results and weights
}


# Ensure save directory exists
os.makedirs(SAVE_DIR, exist_ok=True)

# Load the model with the pre-trained weights
model = YOLO(MODEL_WEIGHTS)

# Train the model with the specified parameters
results = model.train(**TRAINING_PARAMS)

# Save the trained model weights
best_weights_path = os.path.join(SAVE_DIR, "custom_yolo_best.pt")
last_weights_path = os.path.join(SAVE_DIR, "custom_yolo_last.pt")

# Save best and last weights
model.save(best_weights_path)
print(f"Best model weights saved to: {best_weights_path}")

# Optional: If you want to save the last epoch weights separately
model.save(last_weights_path)
print(f"Last epoch model weights saved to: {last_weights_path}")

"""# Predictions
- model initialization
- predict and display results
"""

class WeightSwitcherModel:
    def __init__(self, weight_path_1, weight_path_2):
        """
        Initialize the model with two weight paths.

        Args:
            weight_path_1 (str): Path to the first weight file.
            weight_path_2 (str): Path to the second weight file.
        """
        self.weight_path_1 = weight_path_1
        self.weight_path_2 = weight_path_2
        self.model_1 = YOLO(self.weight_path_1)
        self.model_2 = YOLO(self.weight_path_2)

    def detect_image(self, image_path, custom_weights=True):
        """
        Perform object detection on an image.

        Args:
            image_path (str): Path to the input image.
            use_first_weight (bool): Whether to use the first weight or the second.

        Returns:
            detections (list): A list of detections with bounding boxes, class names, and confidence scores.
        """
        model = self.model_2 if custom_weights else self.model_1
        results = model(image_path,save = True)
        return results

# visualization function

def visualize_predictions(image_path, results):
    """
    Visualize the detection results on the image and save the output.

    Args:
        image_path (str): Path to the input image.
        detections (list): A list of detections with bounding boxes, class names, and confidence scores.
        output_path (str): Path to save the output image.
    """
    boxes = results.boxes.xyxy.cpu().numpy()  # Bounding box coordinates (x_min, y_min, x_max, y_max)
    scores = results.boxes.conf.cpu().numpy()  # Confidence scores
    class_ids = results.boxes.cls.cpu().numpy().astype(int)  # Class IDs
    class_names = results.names  # Class names from the model

    # Load the image
    image = cv2.imread(image_path)  # Assuming results include original image path
    if image is None:
        print("Error: Unable to load image.")
        return

    # Generate unique colors for each class
    unique_classes = set(class_ids)
    class_colors = {class_id: [random.randint(0, 255) for _ in range(3)] for class_id in unique_classes}

    # Draw bounding boxes and labels on the image
    for box, class_id in zip(boxes, class_ids):
        x_min, y_min, x_max, y_max = map(int, box)
        color = class_colors[class_id]
        class_name = class_names[class_id]

        # Draw the bounding box
        cv2.rectangle(image, (x_min, y_min), (x_max, y_max), color, 2)

        # Draw the class name label
        label = f"{class_name}"
        (label_width, label_height), baseline = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2)
        cv2.rectangle(image, (x_min, y_min - label_height - baseline), (x_min + label_width, y_min), color, -1)
        cv2.putText(image, label, (x_min, y_min - baseline), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)

    plt.imshow(image)
    plt.show()

image_path = '/kaggle/input/police-uniform/Police uniform detection.v1i.yolov11/train/images/Image_25_jpg.rf.521641d96169c3c4e7f797ec8f32d0e8.jpg'
general_model = 'yolo11m.pt'
custom_weight = '/kaggle/working/runs/detect/custom_yolo2/weights/best.pt'

model = WeightSwitcherModel(general_model, custom_weight)
results = model.detect_image(image_path, custom_weights=True)
visualize_predictions(image_path, results[0])

"""## confidence Calculation"""

custom_weight = '/kaggle/working/runs/detect/custom_yolo2/weights/best.pt'
image_path = '/kaggle/input/police-uniform/Police uniform detection.v1i.yolov11/train/images/Image_25_jpg.rf.521641d96169c3c4e7f797ec8f32d0e8.jpg'

police_model = YOLO(custom_weight)

# Perform detection on an input image
police_results = police_model(image_path)

# Extract police detections
police_detections = []
for r in police_results:
    for box in r.boxes:
        conf = box.conf[0]  # Confidence score
        xyxy = box.xyxy[0].tolist()  # Bounding box coordinates
        police_detections.append((xyxy, conf))

# Load the pretrained YOLO model (for COCO classes)
person_model = YOLO("yolo11m.pt")  # Replace with a suitable YOLO model

# Perform detection on the same image
person_results = person_model(image_path)

# Extract person detections
person_detections = []
for r in person_results:
    for box in r.boxes:
        cls_id = int(box.cls[0])  # Class ID
        conf = box.conf[0]       # Confidence score
        if cls_id == 0:  # COCO 'person' class ID is 0
            xyxy = box.xyxy[0].tolist()
            person_detections.append((xyxy, conf))


def calculate_iou(box1, box2):
    # Calculate intersection over union (IoU) for two bounding boxes
    x1 = max(box1[0], box2[0])
    y1 = max(box1[1], box2[1])
    x2 = min(box1[2], box2[2])
    y2 = min(box1[3], box2[3])

    intersection = max(0, x2 - x1) * max(0, y2 - y1)
    area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])
    area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])

    union = area1 + area2 - intersection
    return intersection / union if union > 0 else 0

# Match police with person detections
for police_box, police_conf in police_detections:
    for person_box, person_conf in person_detections:
        iou = calculate_iou(police_box, person_box)
        if iou > 0.5:  # IoU threshold for matching
            print(f"Police detected (IoU={iou:.2f}):")
            print(f" - Police confidence: {police_conf:.2f}")
            print(f" - Person confidence: {person_conf:.2f}")

plt.figure(figsize=(8,14))
plt.subplot(2,2,1)
plt.title("custom weight")
img1 = cv2.imread('/kaggle/working/runs/detect/predict13/Image_25_jpg.rf.521641d96169c3c4e7f797ec8f32d0e8.jpg')
plt.axis(False)
plt.imshow(img1)
plt.subplot(2,2,2)
plt.title("general weight")
img2 = cv2.imread('/kaggle/working/runs/detect/predict12/Image_25_jpg.rf.521641d96169c3c4e7f797ec8f32d0e8.jpg')
plt.axis(False)
plt.imshow(img2)
plt.show()

